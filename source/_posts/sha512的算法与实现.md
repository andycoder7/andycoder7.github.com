title: "SHA-512的算法与实现"
date: 2015-05-21 17:44:49
tags: [Hash, C]
categories: 作业
---

## 0x00 背景

这学期在学密码学, 老师布置了一个任务, 要用 C 语言实现 sha-512, 并且最好能输出每一步的内容. 在完成之余, 也对 sha-512 自以为了解了点. 所以记录在这里.

### 0x01 SHA-512

SHA-512 属于 SHA-2家族, 具体说明可参见 [wiki 百科][0]. 是一种安全散列算法(Secure Hash Algorithm). 说的直接点, 就是能把一段任意长度的数据生成一段固定长度的数据. 并且不一样的原文生成的数据也不一样. 不过由于原文无限, 而生成后的数据又是定长的. 所以在生成过程中一定会有数据信息的丢失, 也因此, 该算法一般用于数据摘要来保证数据完整性, 而不是用于加解密保证安全性什么的.

<!-- more -->

## 0x10 算法简介

虽然在上文中说不限制原文数据的长度, 但实际上 SHA-512 要求输入的数据不能超过 2^128次方 bit. 具体原因在了解算法之后便可以理解了. 算法通过对输入数据进行一些运算, 最后得到一段 512bit 的数据段. 我们称这 512bit 的数据段为该数据的"数据摘要".

### 0x11 分组

在具体处理的时候, 由于输入长度的不确定, 所以需要先对输入的数据进行分组. 以 1024bit 为单位划分, 对于最后一个分组, 如果其长度小于 896bit, 那么就填充 1bit "1", 然后一直填充"0", 直到长度达到896, 最后还剩 128bit 则把其当成一个128位的无符号整数, 填入输入数据的长度; 如果最后一个分组长度大于 896bit, 那么也是先填充 1bit "1", 然后一直填"0", 直到再后面一个分组的长度达到 896bit. 最后128位也是一样处理.

![sha分组流程](/images/sha512/group.jpg)

例如: 输入的数据为: "abc", 则其数据长度为 3 * 8 = 24 bit, 所以接下来应该补上 1 位 1, 和 1024 - 128 - 24 - 1 = 871 位 0, 最后在 128bit 中填入无符号的128位整数: 24;
如果输入的数据长度为 1024bit, 那么就直接在下一个分组中填入一位 1 和 895 位 0, 最后 128 填入无符号的128位整数: 1024; 其它情况类似.

PS: unsigned long long 是无符号64位整数, 所以无符号128位整数也是类似的. 你可以想想有一个数据类型是 unsigned long long long long, 那就是无符号128位整型了. 哈哈. 只是在程序具体的处理上需要一些技巧. 另: 知道为什么 SHA-512的最长输入只能是 2^128次方 了么? 因为后面表示数据长度的地方只有 128bit, 所以能表达的最大长度只能是: (2^128 - 1)bit

### 0x12 数据摘要

分组完成之后, 那么不管原始的数据多长(小于2^128次方), 都会变成 N 个 1024 bit 的分组. 然后我们给第一个分组一段初始的 512 bit 的数据, 通过一定的运算得到一段基本上完全不同的 512bit 的数据, 并把该数据作为第二个分组的输入. 以此类推, 直到最后一个分组生成出 512bit 的数据段, 最后得到的这个数据段则为该消息的"数据摘要".

那么问题来了, 初始的 512bit 数据是怎么来的? 对每个分组我们又是怎么运算的呢?

- 初始的 512bit 的数据

在每个分组进行运算的时候, 中间结果和最终结果都是保存在一个 512 bit 的缓冲区中, 我们用8个64位的寄存器(a,b,c,d,e,f,g,h)表示. 这8个64位寄存器的初始值为前8个素数取平方根, 然后取其小数部分的前64位获得. 由于是定值, 所以我们在这里直接给出:

```c
   a = 0x6A09E667F3BCC908    e = 0x510E527FADE682D1
   b = 0xBB67AE8584CAA73B    f = 0x9B05688C2B3E6C1F
   c = 0x3C6EF372FE94F82B    g = 0x1F83D9ABFB41BD6B
   d = 0xA54FF53A5F1D36F1    h = 0x5BE0CD19137E2179
```
- 对于每个分组如何运算

有了这初始的 512 bit 的数据, 那么剩下的问题就是这 512 bit 的数据和每个分组的 1024 bit 的数据如何结合在一起运算了. 由于每个分组的运算都完全一致, 所以我们抽象出来, 计算第 i 个分组. 为了方便表示, 我们称第 i 个分组初始的512位数据为 H[i-1], 在运算完成后, 得到的 512bit 的数据段为 H[i], 所以, 第 1 个分组的初始数据 H[0], 也就是上面列出的那8个64位寄存器的值. 运算完后得到的 512bit 的数据段 H[1] 作为第 2 个分组的初始 512bit 数据输入...

在具体每个分组的运算中, 一共可分为80轮运算, 和之前的分组一样, 每轮运算的过程都基本一致. 在得到最后一轮结果之后, 再与初始的 H[i-1] 进行模2^64次方加法, 得到这个分组运算最终的结果. 所以我们直接讨论第 t 轮的情况, 其他轮类似.

### 0x13 轮函数的参数

对于每一轮, 我们拥有的输入包括: 8个64位寄存器 a ~ h, 也就是 H[i-1], 另外, 还有来自于分组数据 M[i] 的64位数据 W[t], 和用于混淆的64位常数 K[t]. 整体流程图如下:

![sha分组流程](/images/sha512/wheel.jpg)

- W[t]的生成方式:
    - 前16轮, W[t] 为 M[i] 的前16个64位数据段;
    - 后64轮, W[t] = Gamma1(W[t - 2]) + W[t - 7] + Gamma0(W[t - 15]) + W[t - 16]
    - Gamma1(x) = ROTR(x, 19) ^ ROTR(x, 61) ^ SHR(x, 6)
    - Gamma0(x) = ROTR(x, 1) ^ ROTR(x, 8) ^ SHR(x, 7)
    - ROTR(x, n) 表示把64位的 x 循环右移 n 位
    - SHR(x, n) 表示把64位的 x 右移 n 位, 左边补0
    - ^ 表示异或操作

- K[t] 的生成方式:
   - K[t]的生成和之前 abcdefgh 的生成类似, 对前80个素数开立方根, 然后取小数部分的前64位, 所以这80个数都是常数, 我们也称之为"轮常数". 
```c
/* the K array */
static const ulong64 K[80] = {
    CONST64(0x428a2f98d728ae22), CONST64(0x7137449123ef65cd),
    CONST64(0xb5c0fbcfec4d3b2f), CONST64(0xe9b5dba58189dbbc),
    CONST64(0x3956c25bf348b538), CONST64(0x59f111f1b605d019),
    CONST64(0x923f82a4af194f9b), CONST64(0xab1c5ed5da6d8118),
    CONST64(0xd807aa98a3030242), CONST64(0x12835b0145706fbe),
    CONST64(0x243185be4ee4b28c), CONST64(0x550c7dc3d5ffb4e2),
    CONST64(0x72be5d74f27b896f), CONST64(0x80deb1fe3b1696b1),
    CONST64(0x9bdc06a725c71235), CONST64(0xc19bf174cf692694),
    CONST64(0xe49b69c19ef14ad2), CONST64(0xefbe4786384f25e3),
    CONST64(0x0fc19dc68b8cd5b5), CONST64(0x240ca1cc77ac9c65),
    CONST64(0x2de92c6f592b0275), CONST64(0x4a7484aa6ea6e483),
    CONST64(0x5cb0a9dcbd41fbd4), CONST64(0x76f988da831153b5),
    CONST64(0x983e5152ee66dfab), CONST64(0xa831c66d2db43210),
    CONST64(0xb00327c898fb213f), CONST64(0xbf597fc7beef0ee4),
    CONST64(0xc6e00bf33da88fc2), CONST64(0xd5a79147930aa725),
    CONST64(0x06ca6351e003826f), CONST64(0x142929670a0e6e70),
    CONST64(0x27b70a8546d22ffc), CONST64(0x2e1b21385c26c926),
    CONST64(0x4d2c6dfc5ac42aed), CONST64(0x53380d139d95b3df),
    CONST64(0x650a73548baf63de), CONST64(0x766a0abb3c77b2a8),
    CONST64(0x81c2c92e47edaee6), CONST64(0x92722c851482353b),
    CONST64(0xa2bfe8a14cf10364), CONST64(0xa81a664bbc423001),
    CONST64(0xc24b8b70d0f89791), CONST64(0xc76c51a30654be30),
    CONST64(0xd192e819d6ef5218), CONST64(0xd69906245565a910),
    CONST64(0xf40e35855771202a), CONST64(0x106aa07032bbd1b8),
    CONST64(0x19a4c116b8d2d0c8), CONST64(0x1e376c085141ab53),
    CONST64(0x2748774cdf8eeb99), CONST64(0x34b0bcb5e19b48a8),
    CONST64(0x391c0cb3c5c95a63), CONST64(0x4ed8aa4ae3418acb),
    CONST64(0x5b9cca4f7763e373), CONST64(0x682e6ff3d6b2b8a3),
    CONST64(0x748f82ee5defb2fc), CONST64(0x78a5636f43172f60),
    CONST64(0x84c87814a1f0ab72), CONST64(0x8cc702081a6439ec),
    CONST64(0x90befffa23631e28), CONST64(0xa4506cebde82bde9),
    CONST64(0xbef9a3f7b2c67915), CONST64(0xc67178f2e372532b),
    CONST64(0xca273eceea26619c), CONST64(0xd186b8c721c0c207),
    CONST64(0xeada7dd6cde0eb1e), CONST64(0xf57d4f7fee6ed178),
    CONST64(0x06f067aa72176fba), CONST64(0x0a637dc5a2c898a6),
    CONST64(0x113f9804bef90dae), CONST64(0x1b710b35131c471b),
    CONST64(0x28db77f523047d84), CONST64(0x32caab7b40c72493),
    CONST64(0x3c9ebe0a15c9bebc), CONST64(0x431d67c49c100d4c),
    CONST64(0x4cc5d4becb3e42b6), CONST64(0x597f299cfc657e2a),
    CONST64(0x5fcb6fab3ad6faec), CONST64(0x6c44198c4a475817)
};
```

### 0x14 轮函数的逻辑

我们现在知道了参数和输入值的生成方式, 只剩下最后一个问题: 轮函数的内部逻是什么?

从之前的图可知, 轮函数每轮做的事情就是生成新的 a~h. 具体的方式是:

```
    T1 = h + Ch(e, f, g) + Sigma1(e) + W[t] + K[t]
    T2 = Sigma0(a) + Maj(a, b, c)
    h = g
    g = f
    f = e
    e = d + T1
    d = c
    c = b
    b = a
    a = T1 + T2

    说明:   其中T1 T2为临时变量
    Ch(e, f, g) = (e AND f) XOR (NOT e AND g)
    Maj(a, b, c) = (a AND b) XOR (a AND c) XOR (b AND c)
    Sigma1(e) = ROTR(e, 14) ^ ROTR(e, 18) ^ ROTR(e, 41)
    Sigma0(a) = ROTR(a, 28) ^ ROTR(e, 34) ^ ROTR(e, 39)
```

## 0x20 举个栗子

了解了 SHA-512 的全部的算法内容之后, 我们通过一个具体的实例来巩固一下.

现在有待 HASH 的消息: abc. 其数据长度为3 * 8 = 24 bit, 小于 896 bit, 所以只需要直接在后面填充1位1, 和 896 - 24 - 1 = 871位0, 最后128位, 则填入无符号的128位整数: 24, 所以, 最后该分组`M[0]`的具体内容为:

```c
M[0]:   6162638000000000 0000000000000000 0000000000000000 0000000000000000
        0000000000000000 0000000000000000 0000000000000000 0000000000000000
        0000000000000000 0000000000000000 0000000000000000 0000000000000000
        0000000000000000 0000000000000000 0000000000000000 0000000000000018
```

针对该分组, 执行80轮轮函数运算.

```python
第0轮:  W[0]:   0x6162638000000000    K[0]:   0x428a2f98d728ae22
        a =     0x6a09e667f3bcc908    e =     0x510e527fade682d1
        b =     0xbb67ae8584caa73b    f =     0x9b05688c2b3e6c1f
        c =     0x3c6ef372fe94f82b    g =     0x1f83d9abfb41bd6b
        d =     0xa54ff53a5f1d36f1    h =     0x5be0cd19137e2179
        
        Ch(e, f, g) = (e AND f) XOR (NOT e AND g)
                    = (e & f) ^ (~e & g)
                    = (0x510e527fade682d1 & 0x9b05688c2b3e6c1f) ^ (~0x510e527fade682d1 & 0x1f83d9abfb41bd6b)
                    = 0x1104400c29260011 ^ (0xaef1ad8052197d2e & 0x1f83d9abfb41bd6b)
                    = 0x1104400c29260011 ^ 0x0e81898052013d2a
                    = 0x1f85c98c7b273d3b
        其他类似, 直接列出结果:
        Sigma1: 0x9427e33bb5c9dbca    Ch:     0x1f85c98c7b273d3b
        Sigma0: 0x08c4db56aac80c2a    Maj:    0x3a6fe667f69ce92b
        t0:     0xb37b0cfa1b97e8a0    t1:     0x4334c1bea164f555

第1轮:  W[1]:   0x0000000000000000    K[1]:   0x7137449123ef65cd
        a =     0xf6afceb8bcfcddf5    e =     0x58cb02347ab51f91
        b =     0x6a09e667f3bcc908    f =     0x510e527fade682d1
        c =     0xbb67ae8584caa73b    g =     0x9b05688c2b3e6c1f
        d =     0x3c6ef372fe94f82b    h =     0x1f83d9abfb41bd6b

        ...

第79轮: W[79]:  0x92aeeed1a7bcf7d2    K[79]:  0x6c44198c4a475817
        a =     0x10d9c4c4295599f6    e =     0x9bb4d39778c07f9e
        b =     0xd67806db8b148677    f =     0x25c96a7768fb2aa3
        c =     0x654ef9abec389ca9    g =     0xceb9fc3691ce8326
        d =     0xc8960e6be864b916    h =     0x995019a6ff3ba3de

最后得到:
        a =     0x73a54f399fa4b1b2    e =     0xd08446aa79693ed7
        b =     0x10d9c4c4295599f6    f =     0x9bb4d39778c07f9e
        c =     0xd67806db8b148677    g =     0x25c96a7768fb2aa3
        d =     0x654ef9abec389ca9    h =     0xceb9fc3691ce8326
        
再与 H[i-1] 进行模2^64次方加法得到:
    0xddaf35a193617aba 0xcc417349ae204131 0x12e6fa4e89a97ea2 0x0a9eeee64b55d39a
    0x2192992a274fc1a8 0x36ba3c23a3feebbd 0x454d4423643ce80e 0x2a9ac94fa54ca49f
        
```

## 0x30 C语言实现

上面把 SHA-512 的算法原理介绍了, 然后就是具体实现了. 在具体实现部分, 我借鉴了第三方类库: [libtomcrypt][1]. 这个类库实现了几乎所有的安全相关的算法. 并且 C 的源代码也能找的到(src目录下), 所以可以给刚接触密码学方面的小伙伴提供比较大的方便.

不过刚开始上手的时候, 由于对结构的不了解, 还是稍有费劲的. 在此, 我就 sha-512 在其中涉及到的文件进行简单介绍:

- tomcrypt.h
    - 正常来说, 你只要包括这一个头文件即可. 这个头文件里包括了需要用到的所有的头文件和返回的错误代码等信息;
- tomcrypt_argchk.h
    - 在看代码的时候, 经常会看到一个检查参数是否非法的函数: LTC_ARGCHK, 其实现就是在这个头文件里;
- tomcrypt_cfg.h
    - 在这个文件里, 对你的系统信息(32bit/64bit/ENDIAN_BIG/ENDIAN_LITTLE/MSVS)进行了判定, 并定义了一下收到其影响的变量;
- tomcrypt_hash.h
    - 这里面主要要用到的是开始的 sha512_state 的定义和最后的宏函数 HASH_PROCESS;
- tomcrypt_macros.h
    - 这里面根据 tomcrypt_cfg.h 里判定的系统信息的不同, 分别实现了64位读取/写入/循环位移等操作的具体代码
- src/hash/sha2/sha512.c
    - 这里面具体给出了 sha512 的实现代码, 并且有一个test函数可以参考. 基本上所有的工作都是在 sha512_compress 函数中实现的. 至于 test 中用到的 sha512_process 其实就是 tomcrypt_hash.h 中的那个宏函数

## 0x40 结语

1. 相比于百度上各种坑, 还是 github 靠谱.
2. 真心感谢libtomcrypt的作者, Tom St Denis.
3. Hope this will help you. That's all, thank you.


[0]: http://en.wikipedia.org/wiki/SHA-2
[1]: https://github.com/libtom/libtomcrypt
